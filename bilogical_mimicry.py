# -*- coding: utf-8 -*-
"""Bilogical_mimicry.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1SWSq26QPpnxOV0pvIbfVUjDzf6VlM4L_
"""

import random
import math
import matplotlib.pyplot as plt
import numpy as np

def normal_int(v):
  r=np.random.normal(0,v)
  return round(r)

"""Define the traits of the species and class for functionalities of a prey."""

class Species():
  def __init__(self,init_pop_size, signal_distribution,mean, signal_range, multiplication_rate,prey_type,mutation_rate,constraints,value_vector_function,replication_type):
    self.prey_type=prey_type
    self.multiplication_rate=multiplication_rate
    self.mutation_rate=mutation_rate
    self.signal_distribution=signal_distribution
    self.constraints=constraints
    self.init_pop_size=init_pop_size
    self.signal_range=signal_range
    self.value_vector_function=value_vector_function
    self.mean=mean
    self.replication_type=replication_type

  def generate_prey(self,pop_size):
    #value_function is a lambda function that takes a random signal generated by signal_distribution
    prey_list=[]
    while(len(prey_list)<pop_size):
      s = self.signal_distribution(self.mean)
      if s < 1 or s > self.signal_range-1:
        continue
      value_vector=self.value_vector_function(s)
      prey=Prey(s,value_vector,self)
      prey_list.append(prey)
    return prey_list

class Prey():
  def __init__(self,signal, value_vector, species):
    self.species=species #object of class Species
    self.prey_type=self.species.prey_type
    self.signal=signal
    self.isDead=False
    self.value_vector=value_vector # a vector of attributes, which on combination with utility function of predator gives reward to predator

  def replicate(self):
    if self.species.replication_type=="gaussian":
      kid_signal=self.signal+normal_int(self.species.mutation_rate)
    if self.species.replication_type=="luria-delbruck":
      kid_signal=self.signal
      r=random.random()
      if r<self.species.mutation_rate/2:
        kid_signal-=1
      elif r<self.species.mutation_rate:
        kid_signal+=1
    kid_signal=min(self.species.signal_range-1,max(1,kid_signal))
    kid_value_vector=self.find_valid_value_mutation(self.value_vector,self.species.constraints, kid_signal)
    return Prey(kid_signal,kid_value_vector,self.species)

  def find_valid_value_mutation(self,value_vector,constraints, kid_signal):
    if constraints==[]:
      return value_vector
    else:
      print("Error: Constraint programming not defined")
      return None

"""We define different types of predators."""

class Predator():
  def __init__(self,consumption, utility_fn,signal_range):
    self.consumption=consumption
    self.utility_fn=utility_fn
    self.signal_range=signal_range
    self.consumed=0
    self.isDead=False

  def choose_prey(self,signal_list):
    print("Error: choose_prey fn not defined in Predator class")
    return None

  def eat(self,prey):
    print("Error: eat fn not defined in Predator class")
    return None

class min_Predator(Predator):
  def __init__(self,consumption, utility_fn,signal_range):
    Predator.__init__(self,consumption, utility_fn,signal_range)

  def choose_prey(self,signal_list): #Given a list of signals, choose one signal to eat
    min_indx=0
    min_val=signal_list[min_indx]

    for i,s in enumerate(signal_list):
      if s<min_val:
        min_indx,min_val=i,s

    return min_indx

  def eat(self,prey): #eat the chosen prey and obtain utility and learn
    if prey.isDead:
      print("Error: prey already dead")
      return None

    reward=self.utility_fn(prey.value_vector)
    prey.isDead=True
    self.consumed+=1

class UCB_Predator(Predator):
  def __init__(self,consumption, utility_fn,signal_range,alpha,diffusion_range,gamma,epsilon=0):
    Predator.__init__(self,consumption, utility_fn,signal_range)
    self.total_reward=[]
    self.turns=[]
    self.alpha=alpha
    self.diffusion_range=diffusion_range
    self.gamma=gamma
    self.epsilon=epsilon
    for i in range(signal_range):
      self.total_reward.append(0)
      self.turns.append(0)

  def confidence_bound(self,signal,total_turns):
    val=self.total_reward[signal]/self.turns[signal]
    if math.log(total_turns)>0:
      val+=math.sqrt(self.alpha*math.log(total_turns)/(2*self.turns[signal]))
    return val

  def update(self,signal,reward):
    #distribute reward among neighbour signals also
    for i in range(len(self.turns)):
      self.turns[i]*=self.gamma
      self.total_reward[i]*=self.gamma
    for i in range(-self.diffusion_range, self.diffusion_range+1):
      signal_in_range=signal+i 
      if signal_in_range<self.signal_range and signal_in_range>0:
        self.turns[signal_in_range]+=1
        self.total_reward[signal_in_range]+=reward

    #mullerian mimicry can decieve standard ucb learning, if we have a third species withfixed value.
    #but with community or fear of unknown utility we can stop mimicry

  def choose_prey(self,signal_list): #Given a list of signals, choose one signal to eat
    #Every arm should be tried atleast once
    for i,s in enumerate(signal_list):
      if(self.turns[s]==0):
        return i
    if random.random()<self.epsilon:
      return random.randint(0,len(signal_list)-1)
      
    #print("Reward :",self.total_reward)
    #print("Turns :",self.turns)
    #print("Signal_list :",signal_list)
    max_val=-1
    max_indx=-1
    total_turns=0
    for s in signal_list:
      if s >= len(self.turns):
       # print("Error: signal not in required range. Signal: ",s)
       return None
      total_turns+=self.turns[s]

    for i,s in enumerate(signal_list):
      #print("Signal ,Confidence bound:",s,self.confidence_bound(s,total_turns))
      if max_val < self.confidence_bound(s,total_turns):
        max_indx,max_val = i,self.confidence_bound(s,total_turns)

    possibilities=[]
    for i,s in enumerate(signal_list):
      if round(max_val,4)==round(self.confidence_bound(s,total_turns),4):
        possibilities.append(i)
    #print("Possibilities:",possibilities)
    #print("Max indx:",max_indx)
    max_indx=random.choice(possibilities)
    return max_indx

  def eat(self,prey): #eat the chosen prey and obtain utility and learn
    if prey.isDead:
      print("Error: prey already dead")
      return None

    reward=self.utility_fn(prey.value_vector)
    prey.isDead=True
    self.update(prey.signal,reward)
    self.consumed+=1

"""Define the functionalities of the ecosystem"""

class Ecosystem():
  def __init__(self,prey_limit,signal_range,interactions_per_day,predator_pop,prey_pop,prey_types,species_list):
    self.prey_limit=prey_limit
    self.signal_range=signal_range
    self.interactions_per_day=interactions_per_day
    self.predator_pop=predator_pop
    self.prey_pop=prey_pop
    self.prey_types=prey_types
    self.species_list=species_list
    self.dead_so_far_stats={}
    self.alive_stats={}
    for ptype in self.prey_types:
      self.dead_so_far_stats[ptype]=[0]
      self.alive_stats[ptype]=[0]
    for p in self.prey_pop:
      self.alive_stats[p.prey_type][0]+=1

  def random_prey_list(self):
    prey_list=[]
    #tries=0
    while(len(prey_list)<self.interactions_per_day):
      #if(tries < self.interactions_per_day^2):
      #  break
      #tries+=1
      p_idx = int(random.random() * len(self.prey_pop)) 
      p = self.prey_pop[p_idx] 
      #p=random.choice(self.prey_pop)
      if p not in prey_list and not p.isDead:
        prey_list.append(p)

    return prey_list

  def get_signal_list(self,prey_list):
    slist=[]
    for p in prey_list:
      slist.append(p.signal)
    return slist

  def play_day(self, prey_growth_type):
    for prey_type in self.alive_stats.keys():
      self.alive_stats[prey_type].append(0)
      self.dead_so_far_stats[prey_type].append(0)
      self.dead_so_far_stats[prey_type][-1]=self.dead_so_far_stats[prey_type][-2]

    for predator in self.predator_pop:
      predator.consumed=0
    #Daytime : predators eat prey
    for predator in self.predator_pop:
      #tries=0
      while(predator.consumed<predator.consumption):
        #tries+=1
        #If predator does not get enough food it dies so the prey population can bounce back up
        #if(tries > predator.consumption^2 + 1):
        #  predator.isDead=True
        #  break

        prey_list=self.random_prey_list()
        signal_list=self.get_signal_list(prey_list)
        chosen_prey_indx=predator.choose_prey(signal_list)
        prey_chosen=prey_list[chosen_prey_indx]
        predator.eat(prey_chosen)
        #print(signal_list," -> ",prey_chosen.signal)
      #predator.consumed=0

    #Nightime : Remove dead from pop and then Replicate 

    #remove dead prey from population
    new_prey_pop=[]
    for p in self.prey_pop:
      if not p.isDead:
        new_prey_pop.append(p)
      else:
        self.dead_so_far_stats[p.prey_type][-1]+=1
    #remove dead predators from population
    new_predator_pop=[]
    for p in self.predator_pop:
      if not p.isDead:
        new_predator_pop.append(p)

    #let prey replicate till population saturation limit 
    #kid_prey_pop=new_prey_pop
    '''
    total_signal={}
    total_size={}
    total_pop_size=len(new_prey_pop)
    left_to_grow=self.prey_limit-total_pop_size

    for ptype in self.prey_types:
      total_signal[ptype]=0
      total_size[ptype]=0
    for p in new_prey_pop:
      total_signal[p.prey_type]+=p.signal
      total_size[p.prey_type]+=1
    for i,species in enumerate(self.species_list):
      ptype=self.prey_types[i]
      species.mean=total_signal[ptype]/total_size[ptype]

    growth_pop={}
    total_growth_pop=0
    for i,ptype in enumerate(self.prey_types):
      growth_pop[ptype]=total_size[ptype]*self.species_list[i].growth_rate
      total_growth_pop+=growth_pop[ptype]

    if total_growth_pop>left_to_grow:
      for ptype in self.prey_types:
        growth_pop[ptype]*=left_to_grow/(total_growth_pop)
        growth_pop[ptype]=(int)(growth_pop[ptype])

    kid_prey_pop=[]
    for i,ptype in enumerate(prey_types):
      species=self.species_list[i]
      kid_prey_pop+=species.generate_prey(total_size[ptype]+growth_pop[ptype])
    '''
    #if we want new kids by haploid
    kid_prey_pop=[]                                 #
    if prey_growth_type=="Prey Limit - Population rate":
      for parent_prey in new_prey_pop:
        kid_prey=parent_prey.replicate()
        kid_prey_pop.append(kid_prey)
      while(len(kid_prey_pop)<self.prey_limit):
        parent_prey=random.choice(new_prey_pop)
        kid_prey=parent_prey.replicate()
        kid_prey_pop.append(kid_prey)
    elif prey_growth_type=="Multiplication Rate":
      for parent_prey in new_prey_pop:
        m = parent_prey.species.multiplication_rate
        while(m>0):
          r= random.random()
          if r<m:
            kid_prey=parent_prey.replicate()
            kid_prey_pop.append(kid_prey)
          m-=1
        
    
    self.prey_pop=kid_prey_pop
    for p in self.prey_pop:
      self.alive_stats[p.prey_type][-1]+=1
    self.predator_pop=new_predator_pop

  def play_days(self,n,modplot,prey_growth_type):
    for i in range(n):
      if i%modplot==0:
        self.plot_hist(i)
      self.play_day(prey_growth_type)
    self.plot()

  def plot(self):
    print("Alive:",self.alive_stats)
    print("Dead:",self.dead_so_far_stats)
    for ptype in self.prey_types:
      plt.plot(self.alive_stats[ptype])

    plt.title('Population timeline of prey')
    plt.legend(self.prey_types,loc='upper right', shadow=True)
    plt.show()

  def plot_hist(self,day):
    list_of_signal_lists=[]
    ptype_signals={}
    for ptype in self.prey_types:
      ptype_signals[ptype]=[]

    for prey in self.prey_pop:
      ptype_signals[prey.prey_type].append(prey.signal)

    for ptype in self.prey_types:
      list_of_signal_lists.append(ptype_signals[ptype])

    bins = np.linspace(0, self.signal_range, self.signal_range)
    plt.style.use('seaborn-deep')
    plt.hist(list_of_signal_lists, bins, label=self.prey_types)
    plt.title('Signal distribution on '+str(day)+'th day')
    plt.legend(loc='upper right')
    plt.show()

"""Define different prey species and create initial prey population."""

def simulate():
  #Initialise prey population
  prey_limit=20000 
  init_pop_size_A=10000
  init_pop_size_B=10000
  init_pop_size_C=10000
  signal_range = 70
  multiplication_rate_A,multiplication_rate_B,multiplication_rate_C = 1.001,1.001,1.001  #As of right now we assume species grows till prey_limit
  mutation_rate_A,mutation_rate_B,mutation_rate_C = 0.1,0.1,0.1
  constraints=[]

  meanA,meanB,meanC=25,35,45
  def signal_distribution_A(mean):
    return mean+normal_int(5)

  def signal_distribution_B(mean):
    return mean+normal_int(5)

  def signal_distribution_C(mean):
    return mean+normal_int(5)

  def value_vector_fn_A(s):
    #We assume value vector is the same throughout the species.
    return [4]
  def value_vector_fn_B(s):
    #We assume value vector is the same throughout the species.
    return [1]
  def value_vector_fn_C(s):
    #We assume value vector is the same throughout the species.
    return [3]

  replication_type=["gaussian","luria-delbruck"]

  prey_species_A = Species(init_pop_size_A, signal_distribution_A,meanA, signal_range, multiplication_rate_A,'A',mutation_rate_A,constraints,value_vector_fn_A,replication_type[1])
  prey_species_B = Species(init_pop_size_B, signal_distribution_B,meanB, signal_range, multiplication_rate_B,'B',mutation_rate_B,constraints,value_vector_fn_B,replication_type[1])
  prey_species_C = Species(init_pop_size_C, signal_distribution_C,meanC, signal_range, multiplication_rate_C,'C',mutation_rate_C,constraints,value_vector_fn_C,replication_type[1])

  prey_list_A=prey_species_A.generate_prey(prey_species_A.init_pop_size)
  prey_list_B=prey_species_B.generate_prey(prey_species_B.init_pop_size)
  prey_list_C=prey_species_C.generate_prey(prey_species_C.init_pop_size)
  prey_list=prey_list_A+prey_list_B+prey_list_C
  prey_types=[]
  species_list=[]
  for p in prey_list:
    if p.prey_type not in prey_types:
      prey_types.append(p.prey_type)
      species_list.append(p.species)


  A_signal_list=[]
  B_signal_list=[]
  C_signal_list=[]
  for p in prey_list_A:
    A_signal_list.append(p.signal)
  for p in prey_list_B:
    B_signal_list.append(p.signal)
  for p in prey_list_C:
    C_signal_list.append(p.signal)

  prey_pop_growth_types=["Multiplication Rate","Prey Limit - Population rate"]

  #plt.style.use('seaborn-deep')
  #bins = np.linspace(0, signal_range, signal_range)
  #plt.hist([A_signal_list,B_signal_list,C_signal_list], bins, label=['A', 'B', 'C'])
  #plt.legend(loc='upper right')
  #plt.show()


  #initilaise predator population
  def pred_utility_fn(value_vector):
    return value_vector[0]
  daily_consumption =30
  alpha=0
  diffusion_range=0
  gamma=1

  ucb_predator= UCB_Predator(daily_consumption, pred_utility_fn,signal_range,alpha,diffusion_range,gamma)
  min_predator=min_Predator(daily_consumption, pred_utility_fn,signal_range)
  predator_list=[ucb_predator]

  #good with mullerian, bad with batesian??? proability of batesian vs mullerian.

  #simulation
  interactions_per_day=5
  ecosys =Ecosystem(prey_limit,signal_range,interactions_per_day,predator_list,prey_list,prey_types,species_list)
  ecosys.play_days(3001,200,"Multiplication Rate")

simulate()

def simulate():
  #Initialise prey population
  prey_limit=20000 
  init_pop_size_A=0000
  init_pop_size_B=10000
  init_pop_size_C=10000
  signal_range = 70
  multiplication_rate_A,multiplication_rate_B,multiplication_rate_C = 1.001,1.001,1.001  #As of right now we assume species grows till prey_limit
  mutation_rate_A,mutation_rate_B,mutation_rate_C = 0.1,0.1,0.1
  constraints=[]

  meanA,meanB,meanC=25,25,40
  def signal_distribution_A(mean):
    r=random.random()
    if r<0.5:
      return mean+normal_int(5)
    else:
      return mean+15+normal_int(4)

  def signal_distribution_B(mean):
    return mean+normal_int(5)

  def signal_distribution_C(mean):
    return mean+normal_int(4)

  def value_vector_fn_A(s):
    #We assume value vector is the same throughout the species.
    return [4]
  def value_vector_fn_B(s):
    #We assume value vector is the same throughout the species.
    return [1]
  def value_vector_fn_C(s):
    #We assume value vector is the same throughout the species.
    return [3]

  replication_type=["gaussian","luria-delbruck"]

  prey_species_A = Species(init_pop_size_A, signal_distribution_A,meanA, signal_range, multiplication_rate_A,'A',mutation_rate_A,constraints,value_vector_fn_A,replication_type[1])
  prey_species_B = Species(init_pop_size_B, signal_distribution_B,meanB, signal_range, multiplication_rate_B,'B',mutation_rate_B,constraints,value_vector_fn_B,replication_type[1])
  prey_species_C = Species(init_pop_size_C, signal_distribution_C,meanC, signal_range, multiplication_rate_C,'C',mutation_rate_C,constraints,value_vector_fn_C,replication_type[1])

  prey_list_A=prey_species_A.generate_prey(prey_species_A.init_pop_size)
  prey_list_B=prey_species_B.generate_prey(prey_species_B.init_pop_size)
  prey_list_C=prey_species_C.generate_prey(prey_species_C.init_pop_size)
  prey_list=prey_list_A+prey_list_B+prey_list_C
  prey_types=[]
  species_list=[]
  for p in prey_list:
    if p.prey_type not in prey_types:
      prey_types.append(p.prey_type)
      species_list.append(p.species)


  A_signal_list=[]
  B_signal_list=[]
  C_signal_list=[]
  for p in prey_list_A:
    A_signal_list.append(p.signal)
  for p in prey_list_B:
    B_signal_list.append(p.signal)
  for p in prey_list_C:
    C_signal_list.append(p.signal)

  prey_pop_growth_types=["Multiplication Rate","Prey Limit - Population rate"]

  #plt.style.use('seaborn-deep')
  #bins = np.linspace(0, signal_range, signal_range)
  #plt.hist([A_signal_list,B_signal_list,C_signal_list], bins, label=['A', 'B', 'C'])
  #plt.legend(loc='upper right')
  #plt.show()


  #initilaise predator population
  def pred_utility_fn(value_vector):
    return value_vector[0]
  daily_consumption =30
  alpha=0
  diffusion_range=0
  gamma=1

  ucb_predator= UCB_Predator(daily_consumption, pred_utility_fn,signal_range,alpha,diffusion_range,gamma)
  min_predator=min_Predator(daily_consumption, pred_utility_fn,signal_range)
  predator_list=[ucb_predator]

  #good with mullerian, bad with batesian??? proability of batesian vs mullerian.

  #simulation
  interactions_per_day=5
  ecosys =Ecosystem(prey_limit,signal_range,interactions_per_day,predator_list,prey_list,prey_types,species_list)
  ecosys.play_days(1,200,"Multiplication Rate")

simulate()

def simulate():
  #Initialise prey population
  prey_limit=20000 
  init_pop_size_A=10000
  init_pop_size_B=1
  signal_range = 60
  multiplication_rate_A,multiplication_rate_B = 1.0045,1.001  #As of right now we assume species grows till prey_limit
  mutation_rate_A,mutation_rate_B = 0.1,0.1
  constraints=[]

  meanA,meanB=30,35
  def signal_distribution_A(mean):
    return mean+normal_int(5)

  def signal_distribution_B(mean):
    return mean+normal_int(5)

  def value_vector_fn_A(s):
    #We assume value vector is the same throughout the species.
    return [-(s-30)*(s-30)/100]
  def value_vector_fn_B(s):
    #We assume value vector is the same throughout the species.
    return [1]

  replication_type=["gaussian","luria-delbruck"]

  prey_species_A = Species(init_pop_size_A, signal_distribution_A,meanA, signal_range, multiplication_rate_A,'A',mutation_rate_A,constraints,value_vector_fn_A,replication_type[1])
  prey_species_B = Species(init_pop_size_B, signal_distribution_B,meanB, signal_range, multiplication_rate_B,'B',mutation_rate_B,constraints,value_vector_fn_B,replication_type[1])


  prey_list_A=prey_species_A.generate_prey(prey_species_A.init_pop_size)
  prey_list_B=prey_species_B.generate_prey(prey_species_B.init_pop_size)
  prey_list=prey_list_A+prey_list_B
  prey_types=[]
  species_list=[]
  for p in prey_list:
    if p.prey_type not in prey_types:
      prey_types.append(p.prey_type)
      species_list.append(p.species)

  A_signal_list=[]
  B_signal_list=[]
  for p in prey_list_A:
    A_signal_list.append(p.signal)
  for p in prey_list_B:
    B_signal_list.append(p.signal)

  prey_pop_growth_types=["Multiplication Rate","Prey Limit - Population rate"]

  #plt.style.use('seaborn-deep')
  #bins = np.linspace(0, signal_range, signal_range)
  #plt.hist([A_signal_list,B_signal_list], bins, label=['A', 'B'])
  #plt.legend(loc='upper right')
  #plt.show()

  #initilaise predator population
  def pred_utility_fn(value_vector):
    return value_vector[0]
  daily_consumption =30
  alpha=0
  diffusion_range=1
  gamma=1

  ucb_predator= UCB_Predator(daily_consumption, pred_utility_fn,signal_range,alpha,diffusion_range,gamma)
  min_predator=min_Predator(daily_consumption, pred_utility_fn,signal_range)
  predator_list=[ucb_predator]

  #good with mullerian, bad with batesian??? proability of batesian vs mullerian.

  #simulation
  interactions_per_day=5
  ecosys =Ecosystem(prey_limit,signal_range,interactions_per_day,predator_list,prey_list,prey_types,species_list)
  ecosys.play_days(601,200,"Multiplication Rate")

simulate()

"""Polymorphic Mimicry"""

def simulate():
  #Initialise prey population
  prey_limit=20000 
  init_pop_size_A=10000
  init_pop_size_B=10000
  init_pop_size_C=10000
  signal_range = 80
  multiplication_rate_A,multiplication_rate_B,multiplication_rate_C = 1.0005,1.002,1.0005  #As of right now we assume species grows till prey_limit
  mutation_rate_A,mutation_rate_B,mutation_rate_C = 0.1,0.1,0.1
  constraints=[]

  meanA,meanB,meanC=30,45,60
  def signal_distribution_A(mean):
    return mean+normal_int(5)

  def signal_distribution_B(mean):
    return mean+normal_int(5)

  def signal_distribution_C(mean):
    return mean+normal_int(5)

  def value_vector_fn_A(s):
    #We assume value vector is the same throughout the species.
    return [1]
  def value_vector_fn_B(s):
    #We assume value vector is the same throughout the species.
    return [4]
  def value_vector_fn_C(s):
    #We assume value vector is the same throughout the species.
    return [2]

  replication_type=["gaussian","luria-delbruck"]

  prey_species_A = Species(init_pop_size_A, signal_distribution_A,meanA, signal_range, multiplication_rate_A,'A',mutation_rate_A,constraints,value_vector_fn_A,replication_type[1])
  prey_species_B = Species(init_pop_size_B, signal_distribution_B,meanB, signal_range, multiplication_rate_B,'B',mutation_rate_B,constraints,value_vector_fn_B,replication_type[1])
  prey_species_C = Species(init_pop_size_C, signal_distribution_C,meanC, signal_range, multiplication_rate_C,'C',mutation_rate_C,constraints,value_vector_fn_C,replication_type[1])

  prey_list_A=prey_species_A.generate_prey(prey_species_A.init_pop_size)
  prey_list_B=prey_species_B.generate_prey(prey_species_B.init_pop_size)
  prey_list_C=prey_species_C.generate_prey(prey_species_C.init_pop_size)
  prey_list=prey_list_A+prey_list_B+prey_list_C
  prey_types=[]
  species_list=[]
  for p in prey_list:
    if p.prey_type not in prey_types:
      prey_types.append(p.prey_type)
      species_list.append(p.species)


  A_signal_list=[]
  B_signal_list=[]
  C_signal_list=[]
  for p in prey_list_A:
    A_signal_list.append(p.signal)
  for p in prey_list_B:
    B_signal_list.append(p.signal)
  for p in prey_list_C:
    C_signal_list.append(p.signal)

  prey_pop_growth_types=["Multiplication Rate","Prey Limit - Population rate"]

  #plt.style.use('seaborn-deep')
  #bins = np.linspace(0, signal_range, signal_range)
  #plt.hist([A_signal_list,B_signal_list,C_signal_list], bins, label=['A', 'B', 'C'])
  #plt.legend(loc='upper right')
  #plt.show()


  #initilaise predator population
  def pred_utility_fn(value_vector):
    return value_vector[0]
  daily_consumption =30
  alpha=0
  diffusion_range=0
  gamma=1

  ucb_predator= UCB_Predator(daily_consumption, pred_utility_fn,signal_range,alpha,diffusion_range,gamma)
  min_predator=min_Predator(daily_consumption, pred_utility_fn,signal_range)
  predator_list=[ucb_predator]

  #good with mullerian, bad with batesian??? proability of batesian vs mullerian.

  #simulation
  interactions_per_day=5
  ecosys =Ecosystem(prey_limit,signal_range,interactions_per_day,predator_list,prey_list,prey_types,species_list)
  ecosys.play_days(1001,200,"Multiplication Rate")

simulate()

"""Mullerian **Mimicry**

show how by showing C> A and B. Different closeness of A and B

Different utilities
"""

def simulate():
  #Initialise prey population
  prey_limit=20000 
  init_pop_size_A=10000
  init_pop_size_B=0
  init_pop_size_C=10000
  signal_range = 80
  multiplication_rate_A,multiplication_rate_B,multiplication_rate_C = 1.001,1.001,1.001  #As of right now we assume species grows till prey_limit
  mutation_rate_A,mutation_rate_B,mutation_rate_C = 0.1,0.1,0.1
  constraints=[]

  meanA,meanB,meanC=42,45,48
  def signal_distribution_A(mean):
    return mean+normal_int(5)

  def signal_distribution_B(mean):
    return mean+normal_int(5)

  def signal_distribution_C(mean):
    return mean+normal_int(5)

  def value_vector_fn_A(s):
    #We assume value vector is the same throughout the species.
    return [4-s/20]
  def value_vector_fn_B(s):
    #We assume value vector is the same throughout the species.
    return [4]
  def value_vector_fn_C(s):
    #We assume value vector is the same throughout the species.
    return [s/20]

  replication_type=["gaussian","luria-delbruck"]

  prey_species_A = Species(init_pop_size_A, signal_distribution_A,meanA, signal_range, multiplication_rate_A,'A',mutation_rate_A,constraints,value_vector_fn_A,replication_type[1])
  prey_species_B = Species(init_pop_size_B, signal_distribution_B,meanB, signal_range, multiplication_rate_B,'B',mutation_rate_B,constraints,value_vector_fn_B,replication_type[1])
  prey_species_C = Species(init_pop_size_C, signal_distribution_C,meanC, signal_range, multiplication_rate_C,'C',mutation_rate_C,constraints,value_vector_fn_C,replication_type[1])

  prey_list_A=prey_species_A.generate_prey(prey_species_A.init_pop_size)
  prey_list_B=prey_species_B.generate_prey(prey_species_B.init_pop_size)
  prey_list_C=prey_species_C.generate_prey(prey_species_C.init_pop_size)
  prey_list=prey_list_A+prey_list_B+prey_list_C
  prey_types=[]
  species_list=[]
  for p in prey_list:
    if p.prey_type not in prey_types:
      prey_types.append(p.prey_type)
      species_list.append(p.species)


  A_signal_list=[]
  B_signal_list=[]
  C_signal_list=[]
  for p in prey_list_A:
    A_signal_list.append(p.signal)
  for p in prey_list_B:
    B_signal_list.append(p.signal)
  for p in prey_list_C:
    C_signal_list.append(p.signal)

  prey_pop_growth_types=["Multiplication Rate","Prey Limit - Population rate"]

  #plt.style.use('seaborn-deep')
  #bins = np.linspace(0, signal_range, signal_range)
  #plt.hist([A_signal_list,B_signal_list,C_signal_list], bins, label=['A', 'B', 'C'])
  #plt.legend(loc='upper right')
  #plt.show()


  #initilaise predator population
  def pred_utility_fn(value_vector):
    return value_vector[0]
  daily_consumption =30
  alpha=1
  diffusion_range=0
  gamma=0.9

  ucb_predator= UCB_Predator(daily_consumption, pred_utility_fn,signal_range,alpha,diffusion_range,gamma)
  min_predator=min_Predator(daily_consumption, pred_utility_fn,signal_range)
  predator_list=[ucb_predator]

  #good with mullerian, bad with batesian??? proability of batesian vs mullerian.

  #simulation
  interactions_per_day=5
  ecosys =Ecosystem(prey_limit,signal_range,interactions_per_day,predator_list,prey_list,prey_types,species_list)
  ecosys.play_days(3001,200,"Prey Limit - Population rate")

simulate()

#consider each species as a gaussian distribution.

#interesting babbaling equilibria -> donto converge to optimal

#bayes-UCB

#regret - opt-act


#value vector is a guassian dist, based on how far from mean.