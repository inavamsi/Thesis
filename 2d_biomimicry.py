# -*- coding: utf-8 -*-
"""2D Biomimicry

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1GY1qWQ6kjKYbICULGX1ag5Ny4I55zo11
"""

import random
import math
import matplotlib.pyplot as plt
import numpy as np

def normal_int(v):
  r=np.random.normal(0,v)
  return round(r)

class Species():
  def __init__(self,init_pop_size, signal_distribution,mean, signal_range, multiplication_rate,prey_type,mutation_rate,constraints,value_vector_function,replication_type, max_dist):
    self.prey_type=prey_type
    self.multiplication_rate=multiplication_rate
    self.mutation_rate=mutation_rate
    self.signal_distribution=signal_distribution
    self.constraints=constraints
    self.init_pop_size=init_pop_size
    self.signal_range=signal_range
    self.value_vector_function=value_vector_function
    self.mean=mean
    self.replication_type=replication_type
    self.max_dist=max_dist

  def generate_prey(self,pop_size):
    #value_function is a lambda function that takes a random signal generated by signal_distribution
    prey_list=[]
    while(len(prey_list)<pop_size):
      s = self.signal_distribution(self.mean)
      flag=False
      for i in s:
        if i < 1 or i > self.signal_range-1:
          flag=True
          break
      if(flag):
        continue
      value_vector=self.value_vector_function(s)
      prey=Prey(s,value_vector,self)
      prey_list.append(prey)
    return prey_list

class Prey():
  def __init__(self,signal, value_vector, species):
    self.species=species #object of class Species
    self.prey_type=self.species.prey_type
    self.signal=signal
    self.isDead=False
    self.value_vector=value_vector # a vector of attributes, which on combination with utility function of predator gives reward to predator

  def signal_dist(self, s1,s2):
    d=0
    for i in range(len(s1)):
      d+=(s1[i]-s2[i])**2
    return math.sqrt(d)

  def replicate(self):
    while(True):
      if self.species.replication_type=="gaussian":
        kid_signal=self.signal
        for i in range(len(self.signal)):
          kid_signal[i]+=normal_int(self.species.mutation_rate)
      if self.species.replication_type=="luria-delbruck":
        kid_signal=self.signal
        for i in range(len(self.signal)):
          r=random.random()
          if r<self.species.mutation_rate[i]/2:
            kid_signal[i]-=1
          elif r<self.species.mutation_rate[i]:
            kid_signal[i]+=1
          kid_signal[i]=min(self.species.signal_range-1,max(1,kid_signal[i]))
      kid_value_vector=self.find_valid_value_mutation(self.value_vector,self.species.constraints,kid_signal)

      if self.signal_dist(self.species.mean,kid_signal) < self.species.max_dist*(1+random.random()/2):
        break
    return Prey(kid_signal,kid_value_vector,self.species)

  def find_valid_value_mutation(self,value_vector,constraints, kid_signal):
    if constraints==None:
      return self.species.value_vector_function(kid_signal)
    elif len(constraints) != len(value_vector):
      print("Error: Constraints length is faulty!")
      return None
    else:
      d_per_signal=0
      for i in range(len(kid_signal)):
        d_per_signal += (kid_signal[i] - self.signal[i])/ self.signal[i]
      d_per_signal/=len(kid_signal)
      new_value_vector=[]
      for i in range(len(value_vector)):
        new_value_vector.append(constraints[i](d_per_signal,value_vector[i]))
      #***********************************************************??
      return new_value_vector

class Predator():
  def __init__(self,consumption, utility_fn,signal_range,signal_view_fn):
    self.consumption=consumption
    self.utility_fn=utility_fn
    self.signal_range=signal_range
    self.consumed=0
    self.isDead=False
    self.signal_view_fn=signal_view_fn

  def choose_prey(self,signal_list):
    print("Error: choose_prey fn not defined in Predator class")
    return None

  def eat(self,prey):
    print("Error: eat fn not defined in Predator class")
    return None

class min_Predator(Predator):
  def __init__(self,consumption, utility_fn,signal_range,signal_view_fn):
    Predator.__init__(self,consumption, utility_fn,signal_range,signal_view_fn)

  def choose_prey(self,hd_signal_list): #Given a list of signals, choose one signal to eat
    signal_list=[]
    for s in hd_signal_list:
      signal_list.append(self.signal_view_fn(s))
    min_indx=0
    min_val=signal_list[min_indx]

    for i,s in enumerate(signal_list):
      if s<min_val:
        min_indx,min_val=i,s

    return min_indx

  def eat(self,prey): #eat the chosen prey and obtain utility and learn
    if prey.isDead:
      print("Error: prey already dead")
      return None

    reward=self.utility_fn(prey.value_vector)
    prey.isDead=True
    self.consumed+=1

class UCB_Predator(Predator):
  def __init__(self,consumption, utility_fn,signal_range,signal_view_fn,alpha,diffusion_range,gamma, epsilon=0):
    Predator.__init__(self,consumption, utility_fn,signal_range,signal_view_fn)
    self.total_reward=[]
    self.turns=[]
    self.alpha=alpha
    self.diffusion_range=diffusion_range
    self.gamma=gamma
    self.epsilon=epsilon
    for i in range(signal_range):
      self.total_reward.append(0)
      self.turns.append(0)

  def confidence_bound(self,signal,total_turns):
    val=self.total_reward[signal]/self.turns[signal]
    if math.log(total_turns)>0:
      val+=math.sqrt(self.alpha*math.log(total_turns)/(2*self.turns[signal]))
    #print("     ",signal,"   ",val,"    ",self.turns[signal],"    ",self.total_reward[signal])
    return val

  def update(self,hd_signal,reward):
    #distribute reward among neighbour signals also
    signal=self.signal_view_fn(hd_signal)
    for i in range(len(self.turns)):
      self.turns[i]*=self.gamma
      self.total_reward[i]*=self.gamma
    for i in range(-self.diffusion_range, self.diffusion_range+1):
      signal_in_range=signal+i 
      if signal_in_range<self.signal_range and signal_in_range>0:
        self.turns[signal_in_range]+=1
        self.total_reward[signal_in_range]+=reward

    #mullerian mimicry can decieve standard ucb learning, if we have a third species withfixed value.
    #but with community or fear of unknown utility we can stop mimicry

  def choose_prey(self,hd_signal_list): #Given a list of signals, choose one signal to eat
    signal_list=[]
    for s in hd_signal_list:
      signal_list.append(self.signal_view_fn(s))

    #Every arm should be tried atleast once
    for i,s in enumerate(signal_list):
      if(self.turns[s]==0):
        return i
    if random.random()<self.epsilon:
      return random.randint(0,len(signal_list)-1)

    #print("Reward :",self.total_reward)
    #print("Turns :",self.turns)
    #print("Signal_list :",signal_list)
    max_val=-1
    max_indx=-1
    total_turns=0
    for s in signal_list:
      if s >= len(self.turns):
       # print("Error: signal not in required range. Signal: ",s)
       return None
      total_turns+=self.turns[s]


    for i,s in enumerate(signal_list):
      #print("Signal ,Confidence bound:",s,self.confidence_bound(s,total_turns))
      if max_val < self.confidence_bound(s,total_turns):
        s_val=self.confidence_bound(s,total_turns)
        max_indx,max_val = i,s_val

    '''possibilities=[]
    for i,s in enumerate(signal_list):
      if round(max_val,4)==round(self.confidence_bound(s,total_turns),4):
        possibilities.append(i)
    print("Possibilities:",possibilities)
    print("Max indx:",max_indx)
    max_indx=random.choice(possibilities)
    '''
    return max_indx

  def eat(self,prey): #eat the chosen prey and obtain utility and learn
    if prey.isDead:
      print("Error: prey already dead")
      return None

    reward=self.utility_fn(prey.value_vector)
    prey.isDead=True
    self.update(prey.signal,reward)
    self.consumed+=1

class Ecosystem():
  def __init__(self,prey_limit,signal_range,interactions_per_day,predator_pop,prey_pop,prey_types,species_list):
    self.prey_limit=prey_limit
    self.signal_range=signal_range
    self.interactions_per_day=interactions_per_day
    self.predator_pop=predator_pop
    self.prey_pop=prey_pop
    self.prey_types=prey_types
    self.species_list=species_list
    self.dead_so_far_stats={}
    self.alive_stats={}
    for ptype in self.prey_types:
      self.dead_so_far_stats[ptype]=[0]
      self.alive_stats[ptype]=[0]
    for p in self.prey_pop:
      self.alive_stats[p.prey_type][0]+=1

  def random_prey_list(self):
    prey_list=[]
    #tries=0
    while(len(prey_list)<self.interactions_per_day):
      #if(tries < self.interactions_per_day^2):
      #  break
      #tries+=1
      p_idx = int(random.random() * len(self.prey_pop)) 
      p = self.prey_pop[p_idx] 
      #p=random.choice(self.prey_pop)
      if p not in prey_list and not p.isDead:
        prey_list.append(p)

    return prey_list

  def get_signal_list(self,prey_list):
    slist=[]
    for p in prey_list:
      slist.append(p.signal)
    return slist

  def play_day(self, prey_growth_type):
    for prey_type in self.alive_stats.keys():
      self.alive_stats[prey_type].append(0)
      self.dead_so_far_stats[prey_type].append(0)
      self.dead_so_far_stats[prey_type][-1]=self.dead_so_far_stats[prey_type][-2]

    for predator in self.predator_pop:
      predator.consumed=0
    #Daytime : predators eat prey
    for predator in self.predator_pop:
      #tries=0
      while(predator.consumed<predator.consumption):
        #tries+=1
        #If predator does not get enough food it dies so the prey population can bounce back up
        #if(tries > predator.consumption^2 + 1):
        #  predator.isDead=True
        #  break

        prey_list=self.random_prey_list()
        signal_list=self.get_signal_list(prey_list)
        chosen_prey_indx=predator.choose_prey(signal_list)
        prey_chosen=prey_list[chosen_prey_indx]
        predator.eat(prey_chosen)
        #print(signal_list," -> ",prey_chosen.signal)
      #predator.consumed=0

    #Nightime : Remove dead from pop and then Replicate 

    #remove dead prey from population
    new_prey_pop=[]
    for p in self.prey_pop:
      if not p.isDead:
        new_prey_pop.append(p)
      else:
        self.dead_so_far_stats[p.prey_type][-1]+=1
    #remove dead predators from population
    new_predator_pop=[]
    for p in self.predator_pop:
      if not p.isDead:
        new_predator_pop.append(p)

    #let prey replicate till population saturation limit 
    #kid_prey_pop=new_prey_pop
    #.....
    #removed.....

    #if we want new kids by haploid
    kid_prey_pop=[]                                 #
    if prey_growth_type=="Prey Limit - Population rate":
      for parent_prey in new_prey_pop:
        kid_prey=parent_prey.replicate()
        kid_prey_pop.append(kid_prey)
      while(len(kid_prey_pop)<self.prey_limit):
        parent_prey=random.choice(new_prey_pop)
        kid_prey=parent_prey.replicate()
        kid_prey_pop.append(kid_prey)
    elif prey_growth_type=="Multiplication Rate":
      for parent_prey in new_prey_pop:
        m = parent_prey.species.multiplication_rate
        while(m>0):
          r= random.random()
          if r<m:
            kid_prey=parent_prey.replicate()
            kid_prey_pop.append(kid_prey)
          m-=1
        
    for s in self.species_list:
      for i in range(len(s.mean)):
        s.mean[i]=0
    self.prey_pop=kid_prey_pop
    for p in self.prey_pop:
      self.alive_stats[p.prey_type][-1]+=1
      for i in range(len(p.species.mean)):
        p.species.mean[i]+=p.signal[i]
    for s in self.species_list:
      for i in range(len(s.mean)):
        if(self.alive_stats[s.prey_type][-1]!=0):
          s.mean[i]/=self.alive_stats[s.prey_type][-1]
        else:
          s.mean[i]=None
    self.predator_pop=new_predator_pop

  def play_days(self,n,modplot,prey_growth_type):
    for i in range(n):
      if i%modplot==0 or i==1:
        self.plot_hist(i)
      self.play_day(prey_growth_type)
    self.plot()

  def plot(self):
    print("Alive:",self.alive_stats)
    print("Dead:",self.dead_so_far_stats)
    c=["blue","green","red"]
    for i,ptype in enumerate(self.prey_types):
      plt.plot(self.alive_stats[ptype],color=c[i])

    plt.title('Population timeline of prey')
    plt.legend(self.prey_types,loc='upper right', shadow=True)
    plt.show()

  def plot_hist(self,day):
    data=(([0,self.signal_range],[0,self.signal_range]),([0,self.signal_range],[0,self.signal_range]),([0,self.signal_range],[0,self.signal_range]))
    
    for p in self.prey_pop:
      for i,ptype in enumerate(self.prey_types):
        if ptype==p.prey_type:
          for j in range(len(p.signal)):
            data[i][j].append(p.signal[j])
          break

    colors = ("blue", "green", "red")
    groups = ("A","B","C")

    # Create plot
    fig = plt.figure()
    ax = fig.add_subplot(1, 1, 1)

    for data, color, group in zip(data, colors, groups):
      x, y = data
      ax.scatter(x, y, alpha=0.8, c=color, edgecolors='none', s=3, label=group)

    plt.title('Signals in generation '+str(day))
    plt.legend(loc=1)
    plt.show()

def simulate():
  #Initialise prey population
  prey_limit=20000 
  init_pop_size_A=1
  init_pop_size_B=3100
  init_pop_size_C=0
  signal_range = 30
  multiplication_rate_A,multiplication_rate_B,multiplication_rate_C = 1.001,1.001,1.001 
  mutation_rate_A,mutation_rate_B,mutation_rate_C = [0.1,0.001],[0.2,0.2],[0.1,0.001]
  constraints_A,constraints_B,constraints_C=None,None,None
  max_dist_A,max_dist_B,max_dist_C = 15,6,25

  meanA=[25,30]
  meanB=[20,20]
  meanC=[25,25]

  def signal_distribution_A(mean):
    return [mean[0]+normal_int(5),mean[1]+normal_int(5)]

  def signal_distribution_B(mean):
    return [mean[0]+normal_int(3),mean[1]+normal_int(3)]

  def signal_distribution_C(mean):
    return [mean[0]+normal_int(5),mean[1]+normal_int(5)]

  def value_vector_fn_A(s):
    #We assume value vector is the same throughout the species.
    return [s[0]/10,s[1]/10]
  def value_vector_fn_B(s):
    #We assume value vector is the same throughout the species.
    return [3+s[0]/10,3+s[1]/10]
  def value_vector_fn_C(s):
    #We assume value vector is the same throughout the species.
    return [s[0]/10,s[1]/10]

  replication_type=["gaussian","luria-delbruck"]

  prey_species_A = Species(init_pop_size_A, signal_distribution_A,meanA, signal_range, multiplication_rate_A,'A',mutation_rate_A,constraints_A,value_vector_fn_A,replication_type[1],max_dist_A)
  prey_species_B = Species(init_pop_size_B, signal_distribution_B,meanB, signal_range, multiplication_rate_B,'B',mutation_rate_B,constraints_B,value_vector_fn_B,replication_type[1],max_dist_B)
  prey_species_C = Species(init_pop_size_C, signal_distribution_C,meanC, signal_range, multiplication_rate_C,'C',mutation_rate_C,constraints_C,value_vector_fn_C,replication_type[1],max_dist_C)

  prey_list_A=prey_species_A.generate_prey(prey_species_A.init_pop_size)
  prey_list_B=prey_species_B.generate_prey(prey_species_B.init_pop_size)
  prey_list_C=prey_species_C.generate_prey(prey_species_C.init_pop_size)
  prey_list=prey_list_A+prey_list_B+prey_list_C
  prey_types=[]
  species_list=[]
  for p in prey_list:
    if p.prey_type not in prey_types:
      prey_types.append(p.prey_type)
      species_list.append(p.species)


  A_signal_list=[]
  B_signal_list=[]
  C_signal_list=[]
  for p in prey_list_A:
    A_signal_list.append(p.signal)
  for p in prey_list_B:
    B_signal_list.append(p.signal)
  for p in prey_list_C:
    C_signal_list.append(p.signal)

  prey_pop_growth_types=["Multiplication Rate","Prey Limit - Population rate"]
  #plt.style.use('seaborn-deep')
  #bins = np.linspace(0, signal_range, signal_range)
  #plt.hist([A_signal_list,B_signal_list,C_signal_list], bins, label=['A', 'B', 'C'])
  #plt.legend(loc='upper right')
  #plt.show()


  #initilaise predator population
  daily_consumption =3
  alpha=0
  diffusion_range=1
  gamma=0.94
  epsilon=0.1

  def pred_utility_fn_2(value_vector):
    return value_vector[0]+value_vector[1]
  def signal_view_fn_2(s):
    return (int)((s[0]+s[1])/2)
  ucb_predator_2= UCB_Predator(daily_consumption, pred_utility_fn_2,signal_range,signal_view_fn_2,alpha,diffusion_range,gamma)
  min_predator=min_Predator(daily_consumption, pred_utility_fn_2,signal_range,signal_view_fn_2)



  predator_list=[ucb_predator_2]

  #good with mullerian, bad with batesian??? proability of batesian vs mullerian.
  #simulation
  interactions_per_day=10
  ecosys =Ecosystem(prey_limit,signal_range,interactions_per_day,predator_list,prey_list,prey_types,species_list)
  ecosys.play_days(6001,500,"Multiplication Rate")

simulate()